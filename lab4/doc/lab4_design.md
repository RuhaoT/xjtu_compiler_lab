# 实验四设计

## 实验要求（用户需求）

目标：在实验三的基础上，对ParsingTable进行SLR(1)冲突分析，生成SLR(1)分析表。

输入：实验三的LR(0)规范族、文法符号的FOLLOW集

输出：SLR(1)分析表（ACTION/GOTO二维表）
SLR（1）分析引入了 FOLLOW 集 来辅助解决部分冲突。在遇到移进 - 归约或归约 - 归约冲突时，通过检查归约项目左部非终结符的 FOLLOW 集与当前输入符号的关系来确定操作。

## 实验设计

### 需求分析

显然该部分是语法分析器的一部分，其目的仍然是生成一个ParsingTable。只是在生成过程中添加了SLR(1)分析来尝试排除冲突。因此应当保持原有的程序不变，在语法分析接口中派生一个新的类SLRParser。

SLR冲突解决大致可以分为四个部分：

1. 计算CFG文法的FOLLOW集。
2. 在ParsingTable中找到所有的冲突。
3. 对每个冲突，尝试参考FOLLOW集来解决冲突。
4. 如果冲突解决全部成功，更新ParsingTable，返回成功；否则返回失败。

从中可以抽象出几个单一职能模块：
1. CFG文法分析器：计算一个给定文法的FIRST集和FOLLOW集。
2. ParsingTable冲突检查工具：检查并记录ParsingTable中的冲突。
3. SLR冲突解决器：尝试解决ParsingTable中的冲突。
4. SLR分析器：将上述三个模块结合起来，完成SLR(1)分析表的生成。

### 关键数据模型设计

#### CFG文法分析器
该模块的输入是CFG文法，输出是FIRST集和FOLLOW集。对于FIRST集，可以使用一个从`cfg_model::symbol`指向`unordered_set<symbol>`的`unordered_map`表示。此外，由于设计时不显式表示空符号，因此需要添加一个`unordered_set<symbol>`来表示FIRST集中拥有空符号的非终结符。

对于FOLLOW集，除了使用`unordered_map`表示外，还需要记录CFG文法的结束符号。

#### ParsingTable冲突检查工具
考虑到该工具对词法分析很常用，将其作为成员函数集成在`ParsingTable`类中。该工具的输入是ParsingTable，输出是冲突列表。冲突列表可以使用一个`multimap<symbol, string>`表示，表示在相应的表格中存在冲突，使用multimap是因为一个symbol可能有多个string同时发生冲突。

#### SLR冲突解决器
冲突解决需要以下几个方面的信息：
1. ParsingTable
2. 对应的CFG文法，用于计算FIRST集和FOLLOW集
3. 每个ParsingTable项对应的LR(0)项目集合

对于前两者，可以直接传入；对于第三者，需要设计一个从`ParsingTable`到LR(0)项目集合的映射。可以使用一个`unordered_map<string, unordered_map<symbol, unordered_set<shared_ptr<Item>>>>`表示。该映射的key为ParsingTable项的字符串表示，value为该项对应的LR(0)项目集合。由于LR(0)项目集合是一个集合，因此可以使用`unordered_set<shared_ptr<Item>>`表示。特别的，这个映射应该在ParsingTable构造时一同产生。


## 实现细节

### CFG文法分析器

CFG文法分析器接受一个CFG文法，提供计算FIRST集和FOLLOW集的功能。其中计算FOLLOW集要求优先计算FIRST集，否则报错。

#### 计算FIRST集

计算FIRST集的算法就是经典的标准算法：
1. 对于每个CFG文法的非终结符号，初始化其FIRST集为空。
2. 对于每个CFG文法的终结符号，初始化其FIRST集为其本身。
3. 对于每个CFG文法的产生式，遍历其右侧符号序列：
   1. 如果该符号是终结符号，则将其加入FIRST集中，并退出。
   2. 如果该符号是非终结符号，则将其FIRST集中的所有非空符号加入到当前FIRST集中，并继续遍历下一个符号。
   3. 如果该符号是空产生式，则将空符号加入到当前FIRST集中，同时查看是否有下一个符号，如果有，将其FIRST集并入当前FIRST集中，退出。
4. 不断重复上述过程，直到所有非终结符号的FIRST集不再变化为止。

但是，注意到我们定义的CFG文法中，空产生式和非空产生式是分别存储在两个不同的`unordered_set`中的，同时在first集的定义中，也没有显式指出空符号，而是单独使用一个`unordered_set<symbol>`来表示。因此在实现时不能简单遍历产生式：
1. 对于每个CFG文法的非终结符号，初始化其FIRST集为空。
2. 查找CFG的可空符号集，将对应的非终结符号加入FIRST集数据结构的含空符号FIRST集中。
3. 对于每个CFG文法的产生式，遍历其右侧符号序列：
   1. 如果该符号是终结符号，则将其加入FIRST集中，并退出。
   2. 如果该符号是非终结符号，则将其FIRST集中的所有非空符号加入到当前FIRST集中，并继续遍历下一个符号。
   3. 如果该符号是空产生式，则将当前产生式的左部符号加入含空符号FIRST集中。接下来，查看是否有下一个符号，如果有，将其FIRST集并入当前FIRST集中，*并且还需要查看第二个符号是否在CFG的可空符号集中，如果在，还需要再次尝试将左部符号加入含空符号FIRST集中*（因为使用集合，所以不会有重复加入问题），退出。
4. 不断重复上述过程，直到所有非终结符号的FIRST集不再变化为止。

#### 计算FOLLOW集

尽管不显示表示空符号在计算FIRST集时带来了额外复杂度，但是在计算FOLLOW集时，单独表示空符号使计算更加简单。

经典的计算FOLLOW集的算法如下：
1. 对于每个CFG文法的非终结符号，初始化其FOLLOW集为空。
2. 对于CFG文法的开始符号，初始化其FOLLOW集为结束符号。
3. 对于每个CFG文法的产生式，遍历其右侧符号序列：
   1. 如果符号是终结符，跳过并遍历下一个符号。
   2. 如果下一个符号是终结符，则将其加入当前非终结符的FOLLOW集中，并继续遍历下一个符号。
   3. 如果下一个符号是非终结符，则将其FIRST集中的所有非空符号加入当前非终结符的FOLLOW集中，并继续遍历下一个符号。
   4. 如果下一个符号是空产生式，或者下一个非终结符的FIRST集包含空符号，则将当前非终结符的FOLLOW集并入下一个非终结符的FOLLOW集中，并继续遍历下一个符号。
4. 不断重复上述过程，直到所有非终结符号的FOLLOW集不再变化为止。

由于单独存储空产生式，实际实现更加直观：
1. 对于每个CFG文法的非终结符号，初始化其FOLLOW集为空。
2. 对于CFG文法的开始符号，初始化其FOLLOW集为结束符号。
3. 对于每个CFG文法的产生式，遍历其右侧符号序列：
   1. 如果符号是终结符，跳过并遍历下一个符号。
   2. 如果下一个符号是终结符，则将其加入当前非终结符的FOLLOW集中，并继续遍历下一个符号。
   3. 如果下一个符号是非终结符，直接将其FIRST集加入当前非终结符的FOLLOW集中（因为不显式表示空符号），并继续遍历下一个符号。
   4. 如果下一个符号是空产生式，或者下一个非终结符能在FIRST集数据结构的包含空符号FIRST集中找到，则将当前非终结符的FOLLOW集并入下一个非终结符的FOLLOW集中，并继续遍历下一个符号。
4. 不断重复上述过程，直到所有非终结符号的FOLLOW集不再变化为止。

### ParsingTable冲突检查工具

实现很简单，只需要遍历Action表中的每一个格子，然后将其中Action个数多于1的格子的坐标，即状态和输入符号，加入冲突列表中即可。

### SLR冲突解决器

尽管SLR冲突解决方法较为直观，然而在实现细节上需要一定考量，下面给出SLR冲突解决器的实现思路：
1. 初始化：复制一个新的ParsingTable，作为SLR分析器的输出表
2. 调用冲突检查工具检查冲突，如果冲突坐标个数为0则直接退出，避免后续计算。
3. 调用CFG文法分析器计算FIRST集和FOLLOW集。
4. 开始遍历每一组冲突坐标：
   1. 对于每一个冲突坐标，获取该坐标对应的LR(0)项目集合。
   2. 对LR(0)项目集合进行第一次遍历，其职能是确定是否能解决冲突。
      1. 如果是移进项目，记录其下一个符号。
      2. 如果是规约项目，记录其FOLLOW集。
   3. 检查上述记录下的所有符号和FOLLOW集任意两者之间是否存在交集，如果是则退出整个程序并报告冲突无法解决。
   4. 对LR(0)项目集合进行第二次遍历，尝试解决冲突：
      1. 如果当前冲突坐标的输入符号集合在移进项目中，则将该坐标的Action表项设置为移进项目。
      2. 如果当前冲突坐标的输入符号集合在规约项目中，则将该坐标的Action表项设置为对应的规约项目。
5. 如果每一组冲突都被成功解决了，则将SLR分析器的输出表赋值给原ParsingTable，返回成功；否则返回失败。
