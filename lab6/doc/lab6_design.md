# 实验六设计

## 实验要求（用户需求）

目标：中间代码生成

输入：输入抽象语法树信息或其他，token，源程序等等。

输出：输出中间代码表示，三元式、四元式、三地址方式均可。

备注：文法是上一个实验的文法。

## 实验设计

### 需求分析

先前实验已经完成了语法/语义分析并填充了符号表。本次实验的目的是中间代码生成。特别的，实验没有对中间代码表示做明确要求，因此本次实验主要需要完成：

1. 设计一个中间代码表示及对应的模拟环境，比如模拟一个自定义逻辑寄存器配置、内存空间以及指令架构
2. 增强现有AST属性：现有AST属性完全是为了语法和语义分析设计的，没有考虑到中间代码生成。由于中间代码生成本质上也是遍历AST树，所以需要在其中补充有利代码生成的相关信息。
3. 实现中间代码生成工具，该工具通过遍历AST树、利用符号表等信息生成中间代码。期间它需要维护寄存器、内存空间使用情况等。

### 虚拟生成环境设计

#### 寄存器

考虑到时间和实现复杂性，假设逻辑寄存器分为两类：

- T通用寄存器：用于存储临时变量和中间结果
- R通用寄存器：专门用于函数调用过程，如传递参数、返回值等
- RA通用寄存器：专门用于函数的返回地址。

假设各类寄存器数量无限。

寄存器配合不同作用域的工作流程如下：

- 当进入到一个新作用域后，立刻断定目前所有的T寄存器都是空的。随后，将R寄存器（即传入的参数，如果有的话）依次加载到T寄存器中。此后R寄存器将不再使用，直到当前作用域结束。
- 当从当前作用域返回父作用域时，将返回值结果（如果有的话）存储到R寄存器中。然后根据RA寄存器的内容跳转到父作用域的返回地址。此时RA寄存器将不再使用，直到下一个函数调用。
- 在执行当前作用域语句时，维护寄存器的使用情况。如果遇到函数调用，将目前使用的T寄存器的内容按照编号顺序依次存入栈中。最后在栈顶压入RA寄存器的内容（这是当前函数——而不是要进入的函数——要返回的地址）。
- 在函数调用结束后，首先将RA寄存器从栈顶中弹出并复原，之后将栈中的寄存器内容依次恢复到T寄存器中，然后从R寄存器中取出返回值（如果有的话）。

比如一个程序的运行结构如下

```
main() {
    // 使用T0
    // 使用T1
    T2 = func1(T0, T1); // 调用func1
    // 使用T2
    T2 = func2(T2); // 调用func2
    // 结束
}

func1(R0, R1) {
    // 使用T0
    // 使用T1
    T2 = func3(T0, T1); // 调用func3
    // 返回T2
}

func2(R0) {
    // 使用T0
    // 返回T0
}

func3(R0, R1) {
    // 使用T0
    // 使用T1
    // 返回T0
}
```
在上面的例子中，寄存器使用情况如下：

1. 在`main`函数中，首先T0和T1被使用。随后调用`func1`，将T0和T1分别赋值给R0和R1。之后查看当前作用域使用情况，发现T0和T1被使用，因此将T0和T1的内容依次存入栈中，记录其保存了2个寄存器。接着进入`func1`函数。
2. 进入func1函数后，首先将R0和R1的内容依次加载到T0和T1中。随后T2被使用，调用`func3`函数，将T0和T1传入。此时检查当前作用域使用情况，发现T0和T1被使用，因此将它们的内容依次存入栈中，记录其保存了2个寄存器。接着进入`func3`函数。此时栈中依次是：func1的T0、func1的T1、main的T0、main的T1。
3. 进入`func3`函数后，首先将R0和R1的内容依次加载到T0和T1中。进行各种操作，期间未经打断，最后将T0的内容作为返回值存入R0中。此时栈中依次是：func1的T0、func1的T1、main的T0、main的T1。
4. 从`func3`函数返回`func1`后，查看现场，发现有2个寄存器被保存，因此将栈中的T0和T1依次恢复到T0和T1中（即使后续不使用）。随后将R0的内容（即func3的返回值）存入T2中。此时栈中依次是：main的T0、main的T1。之后将T2的内容存入R0中，准备返回到`main`函数。
5. 从`func1`函数返回`main`后，查看现场，发现有2个寄存器被保存，因此将栈中的T0和T1依次恢复到T0和T1中。随后将R0的内容（即func1的返回值）存入T2中。此时栈中为空。
6. 在`main`函数中，T2被使用，调用`func2`函数，将T2的内容存入R0中。此时检查当前作用域使用情况，发现T0、T1、T2被使用，因此将它们的内容依次存入栈中，记录其保存了3个寄存器。接着进入`func2`函数。此时栈中依次是：main的T0、main的T1、main的T2。
7. 进入`func2`函数后，首先将R0的内容加载到T0中。进行各种操作，期间未经打断，最后将T0的内容作为返回值存入R0中。此时栈中依次是：main的T0、main的T1、main的T2。
8. 从`func2`函数返回`main`后，查看现场，发现有3个寄存器被保存，因此将栈中的T0、T1、T2依次恢复到T0、T1、T2中。随后将R0的内容（即func2的返回值）存入T2中（此时T2被复写，这就是为什么要先恢复寄存器再处理返回值）。此时栈中为空。

#### 内存空间

中间代码生成的逻辑空间分为3个部分：

- 程序代码段：存储中间代码指令
- 数据段：存储全局变量、静态变量等
- 栈段：存储函数调用时的寄存器现场、局部变量等

其地址彼此独立。对程序段，地址以语句为单位，每条语句都有一个唯一地址。对数据段，地址的单位是上个实验中定义的“最小内存单元”。对栈段，每个地址和一个寄存器一一对应。

#### 指令架构

给定的文法如下：
```
P -> D' S' # 程序入口
D' -> epsilon | D' D; # 声明表
D -> T d | T d[num] | T d(A'){D' S'} # 单个声明，分别是声明变量、数组和函数
T -> int | float | void # 类型
A' -> epsilon | A' A; # 形参表
A -> T d | T d[] | T d(T) # 单个形参，形参类型分别是基本类型、数组和函数
S' -> S | S' ; S # 语句表
S -> d = E | d[E] = E | if (B) S | if (B) S else S | while (B) S | return E | {S'} | d(R') # 语句
E -> num | flo | d | d[E] | E + E | E * E | (E) | d(R') # 常规算数表达式
B -> E r E | E # 布尔表达式
R' -> epsilon | R' R, # 实参表
R -> E | d[] | d() # 单个实参，分别是表达式运算结果、数组和函数调用
```

需要满足该文法，至少需要以下指令：

- 寄存器赋值：将一个寄存器的值赋给另一个寄存器
- 寄存器加载：从内存中加载一个值到寄存器
- 寄存器存储：将寄存器的值存储到内存中
- GOTO跳转：无条件跳转到指定地址
- 条件跳转：根据布尔表达式的结果跳转到指定地址
- 寄存器相加：将两个寄存器的值相加并存储到一个寄存器中
- 寄存器相乘：将两个寄存器的值相乘并存储到一个寄存器中
- 小于比较：比较一个寄存器的值是否小于另一个寄存器的值，并将结果存储到一个寄存器中
- 相等比较：比较一个寄存器的值是否等于另一个寄存器的值，并将结果存储到一个寄存器中
- 空指令：用于占位或表示无操作

### 关键数据模型设计

#### 地址格式

为了表示不同的逻辑内存空间，地址格式由两部分组成：逻辑空间名+编号。

#### 中间代码指令格式

规定指令格式为：操作码 + 操作数1 + 操作数2 + 操作数3。其中操作数是可选的，对为空的情况，使用`-`表示。

此外还允许使用标签（label）来标记指令地址，以便进行跳转。标签为可选属性。

## 实现细节

### AST模型增强

#### AST属性增强

期望在语法语义分析结束后，遍历一遍AST树即可生成所需要的代码。这也就是说。当遍历到一个节点时，要用于中间代码生成的所有信息都已经准备好了。

观察实验给定的文法，并不是每个节点都会产生新的中间代码，产生代码的AST节点一定发生在语句表S'及其子节点中（作用域内语句），或是D'/D节点（声明）。

特别说明：此处的需求指节点所需要的内部信息（AST本身的属性信息），不包含外部的寄存器、内存空间等信息。

*S节点产生语句的需求*

- 对于IF/WHILE跳转类语句，B节点应该将结果（值或寄存器）准备好用于判断。此外，S节点应当准备好其所有对应中间代码（不能在后根遍历时直接写入代码，否则IF/WHILE语句无法进行跳转判断）。事实上，这个要求间接指明所有S节点及产生代码的其子节点（E、B、S'）都需要准备好中间代码。
- 对于赋值类语句，其需要的信息是变量信息和要赋值的值（或者寄存器）。变量名已经在符号表中准备好了，因此E节点需要将其结果（值或寄存器）在遍历时准备好。
- 对于函数调用语句，语义分析已经很有先见地维护了实参表到每个实参R的链接，但是每个R，如果其类型为表达式（即子节点为E），应当准备好对应的结果/寄存器。

*E节点产生语句的需求*

同样，其子节点为E、R'应准备好相应的信息。

*B节点产生语句的需求*

同上，需要E节点的结果信息。

*D节点产生语句的需求*

- 变量和数组声明：需要的变量名、类型等都已经准备好了。
- 函数声明：需要子节点D'和S'的所有中间代码片段，因此D'和S'的子节点需要准备所有相应的代码。

#### AST节点代码生成函数

每个AST节点都需要一个代码生成函数，用于生成对应的中间代码。该函数需要根据节点类型和属性，生成相应的中间代码指令，并利用符号表和逻辑环境模拟器进行寄存器和内存的操作。

该函数实现为AST节点的一个方法，其利用以下信息：

- 直接输入：逻辑环境模拟器接口，用于节点和外部信息进行沟通。例如获取新的寄存器、将生成的代码写入中间代码指令列表等。
- 间接输入：AST节点的内部信息，如节点类型、子节点等。这些信息可以通过AST节点的属性访问。

下面设计每个AST节点的代码生成函数的逻辑功能。

*非D'、D、S'、S、E、R'、R、B的其他节点*

生成函数直接返回空，因为这些节点不需要生成中间代码。

*D'节点*

D' -> epsilon | D' D; # 声明表

主要用于汇总所有子节点的中间代码片段。

如果子节点为epsilon，初始化中间片段列表。
如果子节点为D' D，先复制D'的中间片段列表，然后将D的中间代码片段添加到列表末尾。

*D节点*

D -> T d | T d[num] | T d(A'){D' S'} # 单个声明，分别是声明变量、数组和函数

如果为变量/数组声明，无需生成中间代码，直接返回。这是因为符号表已经存在，登记变量寄存器信息/数组内存信息可以通过遍历符号表完成。
如果为函数声明：

1. 初始化中间代码片段。
2. 获取函数对应的label。
3. 在符号表中查找函数定义中的参数量，添加将对应数据从R形寄存器移到T形寄存器的中间代码。将第一条代码的标签设置为函数入口地址。
4. 从D'节点获取所有形参的中间代码片段，并添加到中间代码片段列表中。
5. 从S'节点获取所有函数体的中间代码片段，并添加到中间代码片段列表中。

*S'节点*

S' -> S | S' ; S # 语句表

主要用于汇总所有子节点的中间代码片段。
如果子节点为S，直接将S的中间代码片段添加到列表中。
如果子节点为S' ; S，先复制S'的中间代码片段列表，然后将S的中间代码片段添加到列表末尾。

*S节点*

S -> d = E | d[E] = E | if (B) S | if (B) S else S | while (B) S | return E | {S'} | d(R') # 语句

如果为d = E：
1. 获取变量的寄存器地址。
2. 获取E的结果寄存器。
3. 从E中取出中间代码片段作为当前节点的中间代码片段。
4. 生成寄存器存储指令，将E的结果寄存器的值存储到变量的寄存器地址中。将该指令添加到当前节点的中间代码片段列表中。

如果为d[E] = E：
1. 获取第三个子节点——第一个E的代码列表，添加到当前节点的中间代码片段列表中。
2. 获取第六个子节点——第二个E的代码列表，添加到当前节点的中间代码片段列表中。
3. 获取列表的内存地址和第三个子节点的结果寄存器。
4. 添加一条MUL指令，将结果寄存器的值乘以数组元素大小，得到数组元素的内存地址偏移量。
5. 添加一条ADD指令，将数组基地址和偏移量相加，得到最终的数组元素内存地址。
6. 获取第六个子节点的结果寄存器。
7. 添加一条STORE指令，将结果寄存器的值存储到数组元素的内存地址中。

如果为if (B) S：
1. 将B的中间代码列表添加到当前节点的中间代码片段列表中。
2. 在当前作用域下获取两个新的标签，一个用于进入if语句块，一个用于跳过if语句块。
3. 获取B的结果寄存器。
4. 添加一条条件跳转指令，比较B的结果寄存器，跳转地址是进入语句块的标签。
5. 添加一条无条件跳转指令，跳转到跳过语句块的标签。
6. 将S的中间代码片段的第一个指令打上进入语句块的标签。
7. 将S的中间代码片段添加到当前节点的中间代码片段列表中。
8. 添加一条空指令，并将其打上跳过语句块的标签。

如果为if (B) S else S：
1. 将B的中间代码列表添加到当前节点的中间代码片段列表中。
2. 在当前作用域下获取两个新的标签，一个用于进入if语句块，一个用于进入else语句块。
3. 获取B的结果寄存器。
4. 添加一条条件跳转指令，比较B的结果寄存器，跳转地址是进入语句块的标签。
5. 添加一条无条件跳转指令，跳转到else语句块的标签。
6. 将第五个节点——第一个S的中间代码片段的第一个指令打上进入语句块的标签，并将其添加到当前节点的中间代码片段列表中。
7. 将第六个节点——第二个S的中间代码片段的第一个指令打上进入else语句块的标签，并将其添加到当前节点的中间代码片段列表中。

如果为while (B) S：
1. 将B的中间代码列表添加到当前节点的中间代码片段列表中。
2. 在当前作用域下获取三个新的标签，一个用于进入while语句块，一个用于跳过while语句块，最后一个用于跳转到while判断的标签。
3. 获取B的结果寄存器。
4. 添加一条条件跳转指令，比较B的结果寄存器，跳转地址是进入语句块的标签，并且将该指令的标签设置为while判断的标签。
5. 添加一条无条件跳转指令，跳转到跳过语句块的标签。
6. 将S的中间代码片段的第一个指令打上进入语句块的标签，并将其添加到当前节点的中间代码片段列表中。
7. 添加一条无条件跳转指令，跳转到while判断的标签。
8. 添加一条空指令，并将其打上跳过语句块的标签。

如果为return E：
1. 将E的中间代码列表添加到当前节点的中间代码片段列表中。
2. 获取E的结果寄存器。
3. 添加一条寄存器存储指令，将E的结果寄存器的值（或是E的value）存储到R寄存器中（如果有返回值）。

如果为{S'}：
将S'的中间代码片段添加到当前节点的中间代码片段列表中。（注意在这个文法中，该候选式不会产生新作用域）

如果为d(R')：
0. 将R'节点的中间代码片段添加到当前节点的中间代码片段列表中。
1. 调用逻辑环境模拟器，将所有当前作用域的寄存器内容保存到栈中（T和RA寄存器），将其生成的代码片段添加到当前节点的中间代码片段列表中。
2. 从R'节点中对应的实参列表中获取相关寄存器地址（如果是E，直接获取其寄存器/值，如果是列表，在符号表——寄存器映射中查找），将这些值按照参数列表顺序依次写入到R寄存器中。
3. 获取当前作用域的一个新临时标签，作为函数调用的返回地址。
4. 添加一条寄存器赋值指令，将RA寄存器的值设置刚刚获取的新临时标签。
5. 在符号表中查找函数名对应的函数入口地址，并添加一条GOTO跳转指令，跳转到该函数入口地址。
6. 添加一条空指令，将其标签设置为函数调用的返回地址。
7. 调用逻辑环境环境模拟器，将相关寄存器内容从栈中恢复到T寄存器中（如果有返回值，将R寄存器的值恢复到T寄存器中），将其生成的代码片段添加到当前节点的中间代码片段列表中。

*E节点*
E -> num | flo | d | d[E] | E + E | E * E | (E) | d(R') # 常规算数表达式

如果为num或flo：
1. 获取当前节点的值（num或flo）。
2. 获取一个新的T寄存器。
3. 添加一条寄存器赋值指令，将T寄存器的值设置为当前节点的值。
4. 将这条指令设置为当前节点的中间代码片段。将刚刚获取的寄存器设置为结果寄存器。

如果为d：
不需要生成中间代码，直接从符号表中获取变量的寄存器地址，并将其设置为结果寄存器。

如果为d[E]：
1. 获取第三个子节点——第一个E的代码列表，添加到当前节点的中间代码片段列表中。
2. 获取列表在当前作用域的内存地址和第三个子节点的结果寄存器。
3. 添加一条MUL指令，将结果寄存器的值乘以数组元素大小，得到数组元素的内存地址偏移量。
4. 添加一条ADD指令，将数组基地址和偏移量相加，得到最终的数组元素内存地址。
5. 获取一个新的T寄存器作为结果寄存器。
6. 添加一条寄存器加载指令，从数组元素的内存地址加载值到结果寄存器。将该指令添加到当前节点的中间代码片段列表中。

如果为E + E或E * E：
1. 获取第一个子节点的中间代码片段列表，添加到当前节点的中间代码片段列表中。
2. 获取第三个子节点的中间代码片段列表，添加到当前节点的中间代码片段列表中。
3. 获取第一个子节点的结果寄存器和第三个子节点的结果寄存器。
4. 获取一个新的T寄存器作为结果寄存器。
5. 如果是E + E，添加一条寄存器相加指令，将第一个子节点的结果寄存器和第三个子节点的结果寄存器相加，并将结果存储到结果寄存器中。
6. 如果是E * E，添加一条寄存器相乘指令，将第一个子节点的结果寄存器和第三个子节点的结果寄存器相乘，并将结果存储到结果寄存器中。
7. 将结果寄存器设置为当前节点的结果寄存器。
8. 将刚刚生成的指令添加到当前节点的中间代码片段列表中。

如果为(E)：
只需要传递子节点的中间代码片段列表和结果寄存器即可。

如果为d(R')：
0. 将R'节点的中间代码片段添加到当前节点的中间代码片段列表中。
1. 调用逻辑环境模拟器，将所有当前作用域的寄存器内容保存到栈中（T和RA寄存器），将其生成的代码片段添加到当前节点的中间代码片段列表中。
2. 从R'节点中对应的实参列表中获取相关寄存器地址（如果是E，直接获取其寄存器/值，如果是列表，在符号表——寄存器映射中查找），将这些值按照参数列表顺序依次写入到R寄存器中。
3. 获取当前作用域的一个新临时标签，作为函数调用的返回地址。
4. 添加一条寄存器赋值指令，将RA寄存器的值设置刚刚获取的新临时标签。
5. 在符号表中查找函数名对应的函数入口地址，并添加一条GOTO跳转指令，跳转到该函数入口地址。
6. 添加一条空指令，将其标签设置为函数调用的返回地址。
7. 调用逻辑环境环境模拟器，将相关寄存器内容从栈中恢复到T寄存器中（如果有返回值，将R寄存器的值恢复到T寄存器中），将其生成的代码片段添加到当前节点的中间代码片段列表中。
8. 将R寄存器的值设置为当前节点的结果寄存器。

*R'节点*
R' -> epsilon | R' R, # 实参表
只需要汇总所有子节点的中间代码片段即可。其语义动作已经构建了通向各个具体实参的指针。

如果为空，则初始化中间代码片段列表。
如果为R' R，则先复制R'的中间代码片段列表，然后将R的中间代码片段添加到列表末尾。

*R节点*
R -> E | d[] # 单个实参，分别是表达式运算结果、数组和函数调用

如果为E：
1. 获取E的中间代码片段列表，添加到当前节点的中间代码片段列表中。
2. 获取E的结果寄存器，并将其设置为当前节点的结果寄存器。

如果为d[]:
1. 获取d的内存基地址
2. 获取一个新的T寄存器作为结果寄存器。
3. 添加一条寄存器赋值指令，将d的内存基地址加载到结果寄存器中。
4. 将当前作用域内d和T寄存器通过逻辑环境模拟器注册。

### 中间代码生成工具设计

中间代码生成工具主要包括以下几个部分：

- 生成逻辑环境模拟器：

    - 寄存器管理：维护T寄存器和R寄存器的使用情况，处理寄存器的加载、存储、恢复等操作。这其中包含寄存器和作用域的关系，例如每个作用域内的寄存器使用情况。
    - 内存空间管理：维护程序代码段、数据段和栈段的地址分配和使用情况。
    - 变量和函数管理：维护符号表中变量和函数的信息，比如其对应的寄存器、内存地址等。

- 中间代码生成器：

    - 遍历AST树：使用深度优先遍历（DFS）算法遍历AST树，生成中间代码。
    - 生成中间代码：根据AST节点的类型和属性，生成对应的中间代码指令，并利用生成的逻辑环境模拟器进行寄存器和内存的操作。
    - 输出结果：将生成的中间代码指令输出到指定格式（如文本文件或其他数据结构）。

### 逻辑环境模拟器

逻辑环境模拟器是一个用于模拟寄存器、内存空间和符号表的工具。具有以下属性：

- 作用域寄存器使用情况列表，一个int-int map，记录一个作用域编号已经使用了多少个寄存器（规定寄存器是顺序分配的）。
- 作用域变量——寄存器映射表，记录某个作用域下某个变量名被存储到了哪个寄存器。
- 作用域数组——寄存器映射表，记录某个作用域下某个数组的基地址被存储到了哪个寄存器。
- 作用域——标签列表，记录每个作用域的已存在标签列表，用于生成新标签。
- 函数——入口地址（标签）映射表，记录函数名和其对应的入口地址（标签）。
- 原始符号表，记录符号表中所有变量、函数的信息。
- 栈区使用情况，记录栈的大小。
- 内存使用情况，记录内存的使用大小。
- 中间代码指令列表，记录当前生成的所有中间代码指令。

提供以下方法：

- 获取新的寄存器：根据当前作用域的寄存器使用情况，返回一个新的寄存器编号。
- 获取新的标签：根据当前作用域的标签列表，返回一个新的标签。
- 获取变量寄存器地址：根据变量名和当前作用域，返回变量对应的寄存器地址。
- 获取数组基地址：根据数组名和当前作用域，返回数组的基地址寄存器。
- 获取函数入口地址：根据函数名，返回函数的入口地址（标签）。
- 注册变量作用域——寄存器：将变量名和其寄存器地址注册到当前作用域的变量映射表中。仅在初始化时完成。
- 注册数组作用域——寄存器：将数组名和其基地址寄存器注册到当前作用域的数组映射表中。这是考虑到函数的数组传递。
- 注册函数——入口地址：将函数名和其入口地址（标签）注册到函数入口地址映射表中。仅在初始化时完成。
- 状态保存：将当前作用域的寄存器内容保存到栈中，更新栈信息并返回对应的中间代码片段。
- 状态恢复：从栈中恢复当前作用域的寄存器内容，更新寄存器使用情况并返回对应的中间代码片段。
- 添加中间代码指令：将生成的中间代码指令添加到中间代码指令列表中。
- 输出中间代码：返回当前生成的所有中间代码指令列表。

初始化过程：

输入符号表。

首先遍历所有函数，这是为了保证形参变量的寄存器编号和参数列表顺序的正确性：
- 如果当前符号不是函数，跳过。
- 注册函数到函数入口地址映射表中（这会生成一个新标签）。
- 获取函数的形参列表和子作用域，利用（形参名，子作用域id）在符号表中查找，将变量注册到对应作用域并分配寄存器（这个过程一定要按照形参列表的顺序进行）

第二次遍历所有非函数/形参符号：
- 如果当前符号是函数或形参（通过是否已经注册过判断），跳过。
- 获取符号的类型、名称和相关属性。
- 如果是变量，分配一个新的寄存器并注册到对应的作用域。
- 如果是数组，查看其长度和类型，在内存中分配相应的空间，并注册到对应的作用域。同时，还要将数组的基地址寄存器注册到对应的作用域。

### 中间代码生成器

基本上是一个遍历AST树的工具，和上一个实验中的语法语义分析器很相似。

1. 利用输入的符号表初始化逻辑环境模拟器。
2. 后根遍历AST树，调用每个节点的代码生成函数，传入逻辑环境模拟器接口。
3. 全部结束后，从逻辑环境模拟器中获取所有生成的中间代码指令列表。
4. 输出中间代码指令列表到指定格式（如文本文件或其他数据结构）。