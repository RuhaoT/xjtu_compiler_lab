# 实验五设计

## 实验要求（用户需求）

目标：SLR引导的语义分析框架实现

输入：-SLR(1)分析表（实验四输出）嵌入语义动作的文法规则（文件或硬编码）
- Token流（实验二输出）

输出：- 抽象语法树（AST）的可视化表示，符号表（变量名、类型、作用域），语义错误报告（如类型错误）

要求：在SLR(1)语法分析的基础上，集成语义动作，构建抽象语法树（AST）并维护符号表，完成类型检查和初步语义验证。

额外信息：编译器只针对一个特定的文法。

```
P -> D' S' # 程序入口
D' -> epsilon | D' D; # 声明表
D -> T d | T d[i] | T d(A'){D' S'} # 单个声明
T -> int | float | void; # 类型
A' -> epsilon | A' A; # 形参表
A -> T d | T d[] | T d(T) # 单个形参
S' -> S | S' ; S # 语句表
S -> d = E | d[E] = E | if (B) S | if (B) S else S | while (B) S | return E | {S'} | d(R') # 语句
E -> num | flo | d | d[E] | E + E | E * E | (E) | d(R') # 常规算数表达式
B -> E r E | E # 布尔表达式
R' -> epsilon | R' R, # 实参表
R -> E | d[] | d() # 单个实参
```

## 实验设计

### 需求分析

在先前实验中已经完成了原始程序到token流的转换器，以及从CFG文法到SLR(1)分析表的生成。现在需要在次基础上实现语义分析功能。因此首先需要定义语义动作的结构。

对模型部分：
- 增加面向CFG的语义规则模型：
    - 在语法符号（终结符/非终结符）层面，预设计/定义一系列符号属性。准备的属性集合应该涵盖实验给出测试文法中所有可能的符号属性。
    - 在产生式层面，应该预定义一系列语义动作函数。根据每个AST节点的类型和属性，语义动作函数可以执行不同的操作。比如，对于一个变量声明产生式，可以有一个语义动作函数来处理变量的类型检查和符号表的更新。
    - 在设计语义规则时，应当尽量保证（本设计要求必须保证）所有属性都是综合属性，即每个属性只依赖自身及其子节点的属性，而不依赖于父节点或兄弟节点的属性。否则AST的构建和遍历将会变得复杂，且难以维护。
- 增加符号及符号表模型：
    - 语义分析的最终输出是一个符号表，其是包含了所有符号的符合数据结构。符号表应该支持轻松的增删改查并能够帮助发现重复定义等错误。
    - 符号表的每个表项都是一个符号对象，其中所有的符号都包含一些共有属性，例如名称和类型等。除此之外，符号也可以根据符号类型包含其自定义属性。例如，函数拥有参数列表、返回值类型等属性。而数组（多维）则拥有维度个数、每个维度的长度等属性。符号在设计时也应该支持语义检查。比如某个声明产生式D -> T id在进行语义分析时，发现T的类型是int，而id的类型是float，则应该报错。
- 增加AST模型：
    - 抽象语法树（AST）是语义分析的核心数据结构。每个AST节点用一个CFG文法符号标识，同时根据产生式和父节点/子节点关系构建树结构。AST树模型在设计时就应当支持先根/后跟遍历、按顺序访问子节点（即一个节点符号对应的某个产生式）等操作。
    - 每个抽象语法树节点除了树形结构的基本连接关系和文法符号表示外，应当保存所有相关的符号属性。比如一个变量声明节点应该保存变量名、类型等属性，而一个函数调用节点应该保存函数名、实参列表等属性。同时，如果该节点在符号表中有对应的符号对象，应当使用某种方式和符号表中的符号对象关联起来，毕竟符号表的最重要作用就是方便中间代码生成遍历AST时查找符号。

对实现部分：
- 增加语义动作解析器：
    - 语义动作解析器负责从CFG文法中提取语义动作函数和符号属性列表，并将其转换为可执行的语义动作函数调用。该解析器需要能够处理不同类型的符号属性，并根据产生式右侧符号的顺序生成正确的参数列表。
    - 语义动作解析器还需要能够处理不同类型的语义动作函数，例如赋值、算术运算、布尔表达式等，并将其转换为相应的函数调用。
- 增加基于多栈PDA的SLR(1)-AST构建工具：
    - 该工具的目的是构建AST树，在每个节点中填上其应当拥有的属性、需要调用的函数和相应的参数列表等信息。该工具需要能够处理不同类型的符号，并根据符号类型生成相应的AST节点。
- 增加符号表管理器：
    - 假设AST树生成无误，并且文法语义规则严格符合S型文法。那么根据计算理论符号表管理器只需要对AST树进行一轮先根遍历，调用语义动作解析工具，利用符号表的增删改查功能即可完成符号表的构建和语义检查。

### 关键数据模型设计

#### 目标CFG文法的增广语义规则

```
P -> D' S' # 程序入口
D' -> epsilon | D' D; # 声明表
D -> T d | T d[i] | T d(A'){D' S'} # 单个声明，分别是声明变量、数组和函数
T -> int | float | void; # 类型
A' -> epsilon | A' A; # 形参表
A -> T d | T d[] | T d(T) # 单个形参，形参类型分别是基本类型、数组和函数
S' -> S | S' ; S # 语句表
S -> d = E | d[E] = E | if (B) S | if (B) S else S | while (B) S | return E | {S'} | d(R') # 语句
E -> num | flo | d | d[E] | E + E | E * E | (E) | d(R') # 常规算数表达式
B -> E r E | E # 布尔表达式
R' -> epsilon | R' R, # 实参表
R -> E | d[] | d() # 单个实参，分别是表达式运算结果、数组和函数调用
```

##### 属性设计

为了清晰和可读性，一般情况下我们约定属性名和配置文件中规定的别名一致。

首先从始终位于AST树最底端的终结符开始。终结符的属性比较简单，只分为有具体值的终结符和没有具体值的终结符，前者多一个value属性，后者只有type属性。type属性同时也标明了AST树节点的类型。所有终结符属性显然符合继承属性要求。

- *、+、=、\[、\]、\(、\)、\{、\}、;、,、if、else、while、return、int、float、void
    - 属性1：type，词法分析类别。凡是词法分析中只有类型名而token流中不涉及具体值的终结符都可以使用该属性。比如`if`、`else`、`while`等。
- num、flo、d、r
    - 属性1：type，别名type，值为一个字符串，就是其词法分析类别，示数据类型（int、float、void等），当遇到表达式时就可以用于语法检查了。
    - 属性2：value，别名value，值为一个字符串（由于不知道代码生成后端的具体表示方式，因此这里使用字符串表示，后端可以根据需要转换为具体类型）。比如num的值为数字字符串，flo的值为浮点数字符串，d的值为变量名字符串，r的值为布尔运算（如`<`，`==`）字符串。

设计非终结符的属性：
- T——类型名
    - 属性1：type，别名type，值为一个字符串，表示数据类型（int、float、void等），是其对应词法类别。因为此处T的功能和int、float、void等终结符相同，即指明某个声明语句（变量/函数返回值）的类型，所以其属性也和对应的终结符相同。该属性只依赖于自身，因此符合继承属性要求。
- E——表达式运算结果
    - 属性1：type，别名type，值为一个字符串，此时type负责指示语义分析/中间代码生成器该如何处理该节点。其值可以代表常量，变量、数组元素、函数调用等。对于语义分析器，只需要检查合理性，并在type为常量时向上传递值即可，其他情况是由中间代码生成器处理的。该属性只依赖于其子节点的属性，因此符合继承属性要求。
    - 属性2：data_type，别名data_type，值为一个字符串，表示该表达式的计算结果的数据类型（num-对应int、flo-对应float等）。这个属性可以用于后端代码生成时确定变量的类型。显然该属性也只依赖于其子节点的属性，因此符合继承属性要求。
    - 属性3：value，别名value，值为一个字符串（由于不知道代码生成后端的具体表示方式，因此这里使用字符串表示，后端可以根据需要转换为具体类型）。比如E的值为表达式的计算结果字符串。显然该属性也只依赖于其子节点的属性，因此符合继承属性要求。
- B——布尔表达式
    - 属性1：type，别名type，值为一个字符串，此时type负责指示语义分析/中间代码生成器该如何处理该节点。其值可以代表布尔表达式的结果（如`true`、`false`等），或者是一个布尔运算符（如`<`、`==`等）。对于语义分析器，只需要检查合理性，并在type为常量时向上传递值即可，其他情况是由中间代码生成器处理的。
    - 属性2：data_type，别名data_type，值为一个字符串，表示该布尔表达式的计算结果的数据类型（num-对应int、flo-对应float等）。这个属性可以用于后端代码生成时确定变量的类型。
    - 属性3：value，当且仅当两个子节点都是常量时，值为一个字符串（由于不知道代码生成后端的具体表示方式，因此这里使用字符串表示，后端可以根据需要转换为具体类型）。该属性仅在type为常量时有意义，其余时刻不会访问。
- R——实参
    - 属性1：type，别名type，值为一个字符串，此时type负责指示语义分析/中间代码生成器该如何处理该节点。其值分为以下几种情况：1. E表达式为常量且可以直接给出；2. 需要计算E表达式的值；3. 传入的是一个数组；4. 传入的是一个函数调用。对于语义分析器，只需要检查合理性，并在type为常量时向上传递值即可，其他情况是由中间代码生成器处理的。
    - 属性2：data_type，别名data_type，值为一个字符串，表示该实参的数据类型（num-对应int、flo-对应float等）。这个属性可以用于后端代码生成时确定变量的类型。
    - 属性3：value，别名value，值为一个字符串（由于不知道代码生成后端的具体表示方式，因此这里使用字符串表示，后端可以根据需要转换为具体类型）。该属性仅在type为常量时有意义，其余时刻不会访问。
- R'——实参列表
    - 属性1：type，标识这是一个实参列表。
    - 属性2：arg_number，别名arg_number，值为一个整数，表示该实参列表的参数个数。该属性只依赖于其子节点的属性，因此符合继承属性要求。这个值可以用于判断实参列表是否为空，同时也可以方便语义检查。
- A——形参
    - 属性1：type，表示形参节点类型，分为三类：基本类型形参，数组形参和函数形参。该属性只依赖于自身，因此符合继承属性要求。
    - 属性2：data_type，别名data_type，值为一个字符串，表示该形参的数据类型（num-对应int、flo-对应float等）。这个属性可以用于后端代码生成时确定变量的类型。该属性只依赖于自身，因此符合继承属性要求。
    - 属性3：name，别名name。在程序执行时并不会用到，但是有助于语义检查和调试，例如形参名有没有重复定义等。该属性只依赖于自身，因此符合继承属性要求。
- A'——形参列表
    - 属性1：type，标识这是一个形参列表。
    - 属性2：arg_number，别名arg_number，值为一个整数，表示该形参列表的参数个数。该属性只依赖于其子节点的属性，因此符合继承属性要求。这个值可以用于判断形参列表是否为空，同时也可以方便语义检查。
    - 属性3：arguments，值是一个形参结构体向量。不同于实参列表，形参列表需要向上传递并最终添加到符号表中，因此需要保存形参的具体信息。该属性只依赖于其子节点的属性，因此符合继承属性要求。

